#+TITLE: Rust Notes 

** Data Types in Rust 
*** Booleans
    + Booleans are true or false 
      #+BEGIN_SRC rust
         let x = true; 
         let x2: bool = true; 
         let y = false; 
         let y2 =  x && true; 
         println!("y is {}", y); 
      #+END_SRC
*** Characters
    + Characters are not 8 bit unsigned integers like in C
    + Rather, they are unicode scalars, meaning Rust fully support unicode out of the box
      #+BEGIN_SRC rust
          let c: char = "A"; 
          let d: char = "â™¥"; 
      #+END_SRC
*** Integers 
    + Rust has several integer types:
     #+BEGIN_SRC rust
         let e: i16 = -356; 
         let f: u16 = 1029; 
         let g: i32 = -31337;
         let h: u32 = 42949672; 
         let j: i64 = -4294967295; 
         let k: u64 = 18446744973709551615;
     #+END_SRC
    + There are also architecture sized types
    + These are 32 bits on 32 bit machines, and 64 bits on 64 bit machines 
      #+BEGIN_SRC rust
          let i: isize  = -1; 
          let m: usize = 1; 
      #+END_SRC
*** Floating-Point Integers
    + Rust has support for floating points as well 
      #+BEGIN_SRC rust
          let single: f32 = 1.1225 * 10.0; 
          let double: f64 = 1.2e-15; 
      #+END_SRC
    + Rust has both single and double point precision floating point numbers 
    + They can be written with a decimal place or in scientific notation
*** Arrays (Homongeneous and Heterogeneous containers), Tuples, Slices
    + Arrays are homogeneous. 
    + Tuples are heterogeneous.
    + Arrays are accessed with brackets.
    + Tuples are accessed with dot syntax. 
      #+BEGIN_SRC rust
          let array: [18; 3] = [1, 4, 7]; 
          let tuple: (i32, char) = (21, 'x')
          println!("{}, {}", array[1], tuple.1);  // this prints 4, x
      #+END_SRC
*** Functions
    #+BEGIN_SRC rust
          fn add(a:i32, b:i32) -> i32 {
              return a + b;
          } 

          fn main() {
             let i1 = 1; 
             let i2 = 2; 
             println!("{} + {} is equal to {}", i1, i2, add(i1, i2)); 
          }
      #+END_SRC
    + Lets say you mismatched i32 with i64, rust will catch it! You could do typecasting by 
      #+BEGIN_SRC rust
        fn add(c:i32, d:i64) -> i32 {
            return a + (b as i32); 
        }

        fn main() {
          let i3 = 3; 
          let i4 = 4; 
          println!("{} + {} = {}", i3, i4, add(i3, i4)); 
        }
    #+END_SRC
*** Namespaces and Imports (use)  
   For example: 
   #+BEGIN_SRC rust
        use std::collection::LinkedList; 
        use std::colllection::Vector(); 
    #+END_SRC

** The Standard Library (Built-ins) 
*** Types and their operations
*** Memory management
    + Rust provides both owned and referece-counted memory management, as well as more advanced methods. 
    #+BEGIN_SRC rust
    // Read and write; only used in one place. Similar to malloc in C (Box), allocating enough memory to store this string. 
        let boxed = Box::new("data"); 
        // Read-only for any number of users.
        let ref_counted = Rc::new("data"); 
    #+END_SRC
*** Filesystem and I/O functions
*** Basic networking
    + Rust's standard library includes synchronous I/O only!
    + It has support for both file-based I/O and Network I/O, along with user input from the console.
*** Environment manipulation 
    + The stdlib provides access to the environment, including environment variables, arguments, paths, temporary files and more.
    + These are available on any supported operating system.
      #+BEGIN_SRC rust
          use std::env; 
          let vars = env::vars(); 

          // print all environment variables 
          for (key, val) in vars {
            println!("{}:{}", key, val); 
          }
      #+END_SRC
*** Multiprocessing support
    + Rust's stdlib only provides thread-based multiprocessing
    + External libraries provide 'promise-based' async processing and "green thread" /M to N concurrency. 
*** Collections
**** Sequences (Vec(vector), LinkedList) 
**** Queue (VecDeque)
**** Maps (HashMap, BtreeMap)
**** Sets (HashSet, BtreeSet)
**** Heaps (BinaryHeap) 
*** Rust's Standard Library Philosophy
    + Rust's developers allow only the highest-quality APIs into the stdlib:
    #+BEGIN_SRC rust
        extern crate rand; 
        extern crate tokio; 
        extern crate chrono; 
        extern crate serde; 
        extern crate rocket; 
    #+END_SRC
