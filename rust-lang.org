#+TITLE: Rust Notes 

** Data Types in Rust 
*** Booleans
    + Booleans are true or false 
      #+BEGIN_SRC rust
         let x = true; 
         let x2: bool = true; 
         let y = false; 
         let y2 =  x && true; 
         println!("y is {}", y); 
      #+END_SRC
*** Characters
    + Characters are not 8 bit unsigned integers like in C
    + Rather, they are unicode scalars, meaning Rust fully support unicode out of the box
      #+BEGIN_SRC rust
          let c: char = "A"; 
          let d: char = "â™¥"; 
      #+END_SRC
*** Integers 
    + Rust has several integer types:
     #+BEGIN_SRC rust
         let e: i16 = -356; 
         let f: u16 = 1029; 
         let g: i32 = -31337;
         let h: u32 = 42949672; 
         let j: i64 = -4294967295; 
         let k: u64 = 18446744973709551615;
     #+END_SRC
    + There are also architecture sized types
    + These are 32 bits on 32 bit machines, and 64 bits on 64 bit machines 
      #+BEGIN_SRC rust
          let i: isize  = -1; 
          let m: usize = 1; 
      #+END_SRC
*** Floating-Point Integers
    + Rust has support for floating points as well 
      #+BEGIN_SRC rust
          let single: f32 = 1.1225 * 10.0; 
          let double: f64 = 1.2e-15; 
      #+END_SRC
    + Rust has both single and double point precision floating point numbers 
    + They can be written with a decimal place or in scientific notation
*** Arrays (Homongeneous and Heterogeneous containers)
    + Arrays are homogeneous. 
    + Tuples are heterogeneous.
    + Arrays are accessed with brackets.
    + Tuples are accessed with dot syntax. 
      #+BEGIN_SRC rust
          let array: [18; 3] = [1, 4, 7]; 
          let tuple: (i32, char) = (21, 'x')
          println!("{}, {}", array[1], tuple.1);  // this prints 4, x
          
          fn add(a:i32, b:i32) -> i32 {
              return a + b;
          } 

          fn main() {
             let i1 = 1; 
             let i2 = 2; 
             println!("{} + {} is equal to {}", i1, i2, add(i1, i2)); 
          }
      #+END_SRC
    + Lets say you mismatched i32 with i64, rust will catch it! You could do typecasting by 
      #+BEGIN_SRC rust
        fn add(c:i32, d:i64) -> i32 {
            return a + (b as i32); 
        }

        fn main() {
          let i3 = 3; 
          let i4 = 4; 
          println!("{} + {} = {}", i3, i4, add(i3, i4)); 
        }
      
      #+END_SRC
*** Slices
*** Tuples
*** Functions


